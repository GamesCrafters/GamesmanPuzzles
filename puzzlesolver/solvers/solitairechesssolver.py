from .solver import Solver
from .generalsolver import GeneralSolver
from ..util import PuzzleValue
import queue as q
import progressbar
import gzip
import pickle
import os

class SolitaireChessSolver(GeneralSolver):
    ''' See GeneralSolver for more detailed documentation'''
    def __init__(self, puzzle, *args, dir_path="databases", **kwargs):
        from puzzlesolver.puzzles import Puzzle
        # Initializes self._remoteness = {}, self._queue = q.Queue(), and self.puzzle = puzzle
        GeneralSolver.__init__(self, puzzle, *args, **kwargs)
        if not os.path.exists(dir_path):
            os.makedirs(dir_path)   
        self.path = "{}/{}{}.pickle".format(dir_path, puzzle.id, puzzle.variant)
        self.solvableHashes = []

    def getRemoteness(self, puzzle, *args, **kwargs):
        from puzzlesolver.puzzles import Puzzle
        if not self._remoteness:
            self._read()
        return GeneralSolver.getRemoteness(self, puzzle, *args, **kwargs)

    def solve(self, *args, verbose=False, overwrite=False, **kwargs):
        if not isinstance(self._queue, q.Queue):
            self._queue = q.Queue()

        if self._queue.empty():
            solutions = self.puzzle.generateSolutions()
            if len(list(solutions)) == 0:
                # Initialize Progress Bar
                # if verbose: 
                #     print('Solving {} (Variant {})...'.format(self.puzzle.id, self.puzzle.variant))
                #     bar = progressbar.ProgressBar(max_value=self.puzzle.numPositions)
                # CSP - the position generated by the __init__ method is starting position
                self._cspGenerateSolutions(self._queue, verbose)

            else:
                # Not a CSP - use generateSolutions()
                for solution in solutions: 
                    # Check if all the solutions are SOLVABLE
                    assert solution.primitive() == PuzzleValue.SOLVABLE, "`generateSolutions` contains an UNDECIDED OR UNSOLVABLE position"
                    self._remoteness[hash(solution)] = 0
                    self._queue.put(solution)
        
        if overwrite or not os.path.exists(self.path):
            self._write()
        else:
             print(f'Database file {self.path} found! No need to re-solve.')
             self._read()
    
    def _write(self):
        ''' See PickleSolver for documentation '''
        with open(self.path, "w+b") as fo:
            pickle.dump(self._remoteness, fo)


    def _read(self):
        ''' See PickleSolver for documentation '''
        if not self._remoteness and os.path.exists(self.path):
            with open(self.path, "r+b") as fo:
                self._remoteness = pickle.load(fo)

    def _cspGenerateSolutions(self, queue, verbose=False):
        """
        Traverse the puzzle tree, starting from the position returned from __init__,
        placing primitive positions found in queue.
        """
            
        # DFS Search with backtracking
        # store all paths from start to goal
        self._remoteness = {}
        global_path_stack = []
        global_seen_puzzles = set()
        
        def dfs_helper(puzzle_node, path_stack, seen_puzzles):
            seen_puzzles.add(hash(puzzle_node))

            if puzzle_node.primitive() == PuzzleValue.SOLVABLE:
                path_stack_len = len(path_stack)
                for i in range(len(path_stack)):
                    if hash(path_stack[i]) in self._remoteness:
                        if self._remoteness[hash(path_stack[i])] > path_stack_len - i - 1: 
                            self._remoteness[hash(path_stack[i])] = path_stack_len - i - 1
                    else:
                        self._remoteness[hash(path_stack[i])] = path_stack_len - i - 1
                        # if verbose: bar.update(len(self._remoteness)) 
                return
            
            for next_move in puzzle_node.generateMoves('legal'):
                next_puzzle_node = puzzle_node.doMove(next_move)
                if next_puzzle_node not in seen_puzzles:
                    path_stack.append(next_puzzle_node)
                    dfs_helper(next_puzzle_node, path_stack, seen_puzzles)
                    path_stack.pop()
                    temp = None
            
            # seen_puzzles.remove(hash(puzzle_node))

        global_path_stack.append(self.puzzle)
        dfs_helper(self.puzzle, global_path_stack, global_seen_puzzles)
        # if verbose: bar.finish()
